# DMAP

`dmap` is basically a simple global registry that stores `(zone, name, meta, data)`.

Usage is divided into mainly two functions:

1. `set(name, meta, data)`: sets `s=keccak256(msg.sender, name)` slot to `meta` and `s+1` slot to `data`.
2. `get(name)`: returns `s=keccak256(msg.sender, name)` slot as `meta` and `s+1` as `data`.

Decompiled using [ethervm's decompiler](https://ethervm.io/decompile/0x90949c9937A11BA943C7A72C3FA073a37E3FdD96).

## Examples

Let's manually step through `dmap` bytecode using set and get example.

Create `set` calldata using `abi.encodePacked(SEL, name, meta, data)` where SEL is a `4byte` selector and others are `bytes32`. So, for `set` calls, calldata length should be **100** bytes. And, `get` calldata should be **36** bytes. using `abi.encodePacked(SEL, s)` where `s` is the storage slot from `keccak256(msg.sender, name)`.

First start with a `get` example.

## GET

1. Set up the free-memory pointer.

```bash
0000    60  PUSH1 0x80
0002    60  PUSH1 0x40
0004    52  MSTORE

MEMORY:
0040: 0x0000000000000000000000000000000000000000000000000000000000000080
```

2. Check `calldatasize` to be equal to _36_ as `get` calldata = _36_ bytes.

```bash
0005    36  CALLDATASIZE
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000024 (calldatasize)

0006    60  PUSH1 0x24
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000024 (36 bytes)
0001: 0x0000000000000000000000000000000000000000000000000000000000000024 (calldatasize)

0008    03  SUB
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (sub)

0009    60  PUSH1 0x22
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000022 (jump location)
0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (jump condition)

000B    57  *JUMPI
STACK: 0
```

3. load slot to stack

```bash
000C    60  PUSH1 0x04
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000004 (calldata offset)

000E    35  CALLDATALOAD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000001 (load calldata[0x04:0x24])
```

4. load storage slot to stack and store to `mem[0x00:0x20]`

```bash
000F    54  SLOAD
STACK: 1
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000 (slot value)

0010    60  PUSH1 0x00
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000000
0001: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0012    52  MSTORE
STACK: 0
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000 (slot value)
0040: 0x0000000000000000000000000000000000000000000000000000000000000080
```

5. load s+1 slot to stack

```bash
0013    60  PUSH1 0x04
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000004
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
0040: 0x0000000000000000000000000000000000000000000000000000000000000080

0015    35  CALLDATALOAD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000001 (slot to retrieve)
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0016    60  PUSH1 0x01
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000001
0001: 0x0000000000000000000000000000000000000000000000000000000000000001
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0018    01  ADD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000002
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

0019    54  SLOAD
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000000
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
```

6. store loaded slot to `mem[0x20:0x40]`

```bash
001A    60  PUSH1 0x20
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000020
0001: 0x0000000000000000000000000000000000000000000000000000000000000000
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000

001C    52  MSTORE
STACK: 0
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
0020: 0x0000000000000000000000000000000000000000000000000000000000000000
```

7. return `mem[0x00:0x40]`

```bash
001D    60  PUSH1 0x40
001F    60  PUSH1 0x00
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (memory offset)
0001: 0x0000000000000000000000000000000000000000000000000000000000000040 (memory length)
MEMORY:
0000: 0x022ea9ba506e38ef6093b6ab53e48bbd60f86832000000000000000000000000
0020: 0x0000000000000000000000000000000000000000000000000000000000000000

0021    F3  *RETURN
```

## SET

Now, let's walkthrough a `set` case.

```
name: "dmap" = 0x6e616d6500000000000000000000000000000000000000000000000000000000
meta: "meta" = 0x6d65746100000000000000000000000000000000000000000000000000000000
data: "data" = 0x6461746100000000000000000000000000000000000000000000000000000000

calldata: `abi.encodePacked(0x00000000,name,meta,data)` = 0x000000006e616d65000000000000000000000000000000000000000000000000000000006d657461000000000000000000000000000000000000000000000000000000006461746100000000000000000000000000000000000000000000000000000000
```

1. Jump to `0x22` if `calldatasize > 36`

```bash
0022    5B  JUMPDEST
```

2. push `name=calldata[0x04:0x24]`, `meta=calldata[0x24:0x44]`, `calldata[0x44:0x64]` to stack

```bash
0023    60  PUSH1 0x04
0025    35  CALLDATALOAD
0026    60  PUSH1 0x24
0028    35  CALLDATALOAD
0029    60  PUSH1 0x44
002B    35  CALLDATALOAD

STACK: 3
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

3. store msg.sender at mem[0x00:0x20]

```bash
002C    33  CALLER
002D    60  PUSH1 0x00
002F    52  MSTORE

STACK: 3
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
```


4. store `name` at mem[0x20:0x40]

```bash
0030    82  DUP3
0031    60  PUSH1 0x20
0033    52  MSTORE

STACK: 3
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

5. calculate `keccak256(mem[0x00:0x40])` to find the storage slot

```bash
0034    60  PUSH1 0x40
0036    60  PUSH1 0x00
0038    20  SHA3

STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

6. log the event `(0, 0, msg.sender, name, meta, data)`

```bash
0039    81  DUP2
003A    83  DUP4
003B    85  DUP6
003C    33  CALLER
003D    60  PUSH1 0x00
003F    80  DUP1

STACK: 9
0000: 0
0001: 0
0002: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0003: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0005: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000

0040    A4  LOG4
STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

> Store `data` at `slot + 1`

7. duplicate `data` to stack top and push `1`

```bash
0041    81  DUP2
STACK: 5
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0042    60  PUSH1 0x01
STACK: 7
0000: 01
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

8. duplicate slot and add 1.

```bash
0044    82  DUP3
0045    01  ADD
STACK: 6
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab923 (slot + 1)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

9. store at `storage[slot+1] = data`

```bash
0046    55  SSTORE
STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0000: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

> Next code block checks that `calldatasize=100` and storage slot should be empty.

10. load slot and perform and with 1 to check if slot is empty or not

```bash
0047    80  DUP1
STACK: 5
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0048    54  SLOAD
STACK: 5
0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot value)
0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0049    60  PUSH1 0x01
STACK: 6
0000: 0x01
0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot value)
0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

004B    16  AND
STACK: 5
0000: 0x0000000000000000000000000000000000000000000000000000000000000000
0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

11. check `calldatasize=100`

```bash
004C    36  CALLDATASIZE
STACK: 6
0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)
0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot filled or not)
0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

004D    60  PUSH1 0x64
STACK: 7
0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (100 bytes)
0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)
0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot filled or not)
0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

004F    18  XOR
STACK: 6
0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (calldatasize=100 or not)
0001: 0x0000000000000000000000000000000000000000000000000000000000000000 (slot filled or not)
0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0050    17  OR
STACK: 5
0000: 0x0000000000000000000000000000000000000000000000000000000000000000
0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)
```

12. if true, jump to `0x58` and revert according to calldatasize

```bash
0051    60  PUSH1 0x58
0053    57  *JUMPI
```

13. conditions are fulfilled, store `meta` at storage slot and return

```bash
0054    82  DUP3
STACK: 5
0000: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0001: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0002: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0003: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0004: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0055    81  DUP2
STACK: 6
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0001: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0002: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0003: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0004: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0005: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0056    55  SSTORE
STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0001: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0002: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0003: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0057    00  *STOP
```

> Jump here, if conditions aren't fulfilled i.e. either lock is set or calldata is incorrect.

14. pop everything

```bash
0058    5B  JUMPDEST
STACK: 4
0000: 0xf7fbcbda33204447e5b6bf43e1ab2765746799462c92f997afb4e0d6a2fab922 (slot)
0001: 0x6461746100000000000000000000000000000000000000000000000000000000 (data)
0002: 0x6d65746100000000000000000000000000000000000000000000000000000000 (meta)
0003: 0x6e616d6500000000000000000000000000000000000000000000000000000000 (name)

0059    50  POP
005A    50  POP
005B    50  POP
005C    50  POP

STACK: 0
```

15. check if attempted to write at locked slot by checking `calldatasize=100`

```bash
005D    36  CALLDATASIZE
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)

005E    60  PUSH1 0x64
STACK: 2
0000: 0x64
0001: 0x0000000000000000000000000000000000000000000000000000000000000064 (calldatasize)

0060    03  SUB
STACK: 1
0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (calldatasize - 100)
```

17. jump to `0x74` if calldatasize was wrong
```bash
0061    60  PUSH1 0x74
0063    57  *JUMPI
```

> Revert if attempt to write to a locked slot.

18.  push `LOCKED()` converted to 4bytes

```bash
0064    63  PUSH4 0xa1422f69
STACK: 1
0000: 0x00000000000000000000000000000000000000000000000000000000a1422f69 (4byte error)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

19. shift left by 224 bytes to left align the 4byte error

```bash
0069    60  PUSH1 0xe0
STACK: 2
0000: 0xe0
0001: 0x00000000000000000000000000000000000000000000000000000000a1422f69 (4byte error)
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000

006B    1B  SHL
STACK: 1
0000: 0xa1422f6900000000000000000000000000000000000000000000000000000000
MEMORY:
0000: 0x000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c (caller)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000
```

20. store the error and revert

```bash
006C    60  PUSH1 0x00
006E    52  MSTORE

STACK: 0
MEMORY:
0000: 0xa1422f6900000000000000000000000000000000000000000000000000000000 (4byte error left aligned)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000

006F    60  PUSH1 0x04
0071    60  PUSH1 0x00
STACK: 2
0000: 0x0000000000000000000000000000000000000000000000000000000000000000 (memory offset)
0001: 0x0000000000000000000000000000000000000000000000000000000000000004 (memory length)
MEMORY:
0000: 0xa1422f6900000000000000000000000000000000000000000000000000000000 (4byte error left aligned)
0020: 0x6e616d6500000000000000000000000000000000000000000000000000000000

0073    FD  *REVERT
```

21. revert, if no conditions fulfilled

```bash
0074    5B  JUMPDEST
STACK: 0

0075    60  PUSH1 0x00
0077    80  DUP1
STACK: 2
0000: 0x00 (memory offset)
0001: 0x00 (memory length)

0078    FD  *REVERT
```

22. remaining init opcodes

```bash
0079    FE    *ASSERT
007A    A2    LOG2
007B    64    PUSH5 0x6970667358
0081    22    22
0082    12    SLT
0083    20    SHA3
0084    47    SELFBALANCE
0085    5E    5E
0086    23    23
0087    8F    DUP16
0088    09    MULMOD
0089    C0    C0
008A    7B    PUSH28 0x2df011287cd0b887d9e0864657776ab6a3484c43f79237fefa64736f
00A7    6C    PUSH13 0x634300080d0033
```